<!DOCTYPE html>
<html>
<head>
	<title>Arrow Functions 2</title>
</head>
<body>
	<h1> Arrow </h1>
</body>
<script type="text/javascript">
	const numbers = [2, 4, 6, 8, 10];

	/* As I say, you can use arrow functions like anonymous functions, and that 
	means that you can use them in places like here */
	let double = numbers.map(number => number * 2);

	//console.log(double);

	var personES5 = {
		firstname: 'Nick',
		lastname: 'Doe',
		sayFullName: function(){
			//var that = this;

			/* In es5 functions, you need to define a that variable
			to keep the this object, or you can use bind, to bind the this object */
			return function(){
				//console.log(this);
				console.log(this.firstname + ' ' + this.lastname);
			}.bind(this);
		}
	}

	personES5.sayFullName()();

	const personES6 = {
		firstname: 'Nick',
		lastname: 'Doe',
		/*sayFullName: function() {*/
		sayFullName() {
			return () => {
				/* But in es6 is totally differently because arrow functions 
				doesnt interrump the pass of this */

				console.log(this);
				console.log(`${this.firstname} ${this.lastname}`);
			}
		}
	}

	personES6.sayFullName()();

	document.querySelector('h1').addEventListener('click', function(){
		/*let a = function(){*/
		let a = ()=>{
			/* As I say arrow functions allows the pass of this, if it was
			a normal function expression, it'll dont work */
			this.style.color = 'red';
		}

		a();
	})

</script>
</html>